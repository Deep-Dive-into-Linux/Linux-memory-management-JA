ユーザプロセスのメモリ配置について学ぶ。
ある一つのユーザプロセスのアドレス空間は以下のようになっている。

```
低位アドレス 0x0000000000000000   NULL
                                ------------------------------
                                text : CPU の命令コードを格納
                                ------------------------------
                                data : 初期値がある static 変数、global 変数。C 言語では、初期値が 0 以外の初期値を持つ static 変数・global 変数
                                ------------------------------
                                bss  : 初期値が設定されてない static 変数、global 変数。C 言語では、初期値が 0 の static 変数・global 変数
                                ------------------------------
                                heap : malloc、インスタンスを生成するなどして動的に割り当てられるメモリ空間
                                ------------------------------
                                ↓
                                ↑
                                ------------------------------
                                stack : スタック領域
                                ------------------------------
           0xc000000000000000   kernel 領域
高位アドレス 0xffffffffffffffff
```

- virtual address 空間の大きさ
  64 bits のシステムは linear address 空間で virtual address を使用。理論的には 0x0000000000000000 ~ 0xffffffffffffffff が使用できる。16 進数で表記してるので、f つまり 10 進数で 15、2 進数で 1111 なので、0 が 16 個、f が 16 個並んでるこの範囲は 64 bits の理論上の割り当て可能な範囲と言える。
- stack には、関数の局所変数(auto 変数、static が付かないもの)、関数の引数が置かれる。
- stack の底には、引数と環境変数が置かれる。
- stack は、高位アドレスから低いアドレスへ伸びる。
- heap は、低位アドレスから高いアドレスへ伸びる。
- 0 番地付近は、メモリを割り当てないことが一般的。NULL ポインタの利用 ですぐに落ちる。
- Linux x86 (64 bits) では、0xc000000000000000 ~ 0xffffffffffffffff の間は、kernel が使うので、ユーザは使用できない。

実際に x86_64 システムでの virtual memory の memory maps に関しては、以下を参照するのが kernel バージョンに応じて以下を参照するのがわかりやすいと思われる。ちなみに、arm64 に関してのドキュメントも以下サイトにあるので、見比べてみるのも良い。

- The Linux Kernel Archives
  https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/Documentation/x86/x86_64/mm.rst?h=v5.4.286
